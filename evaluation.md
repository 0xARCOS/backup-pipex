Perfecto. Investigaré todo lo necesario sobre el proyecto Pipex de 42 School: objetivos, requisitos técnicos, criterios de evaluación, errores comunes, estándares de estilo y cualquier documentación oficial o rúbrica usada para evaluarlo. También identificaré cómo estructurar una hoja de corrección completa y transferible a tu propio proyecto.

Te aviso en cuanto lo tenga listo.


# Proyecto Pipex (42 School) – Hoja de Corrección

## Descripción del Proyecto Pipex

El proyecto **Pipex** de la escuela 42 consiste en desarrollar un pequeño programa en C que reproduzca el comportamiento de las *pipelines* de la shell (el operador `|`). En concreto, el programa debe tomar la salida de un primer comando y proporcionarla como entrada a un segundo comando, redirigiendo la entrada y salida estándar desde/ hacia ficheros externos. El propósito pedagógico es familiarizar al estudiante con conceptos básicos de UNIX: manejo de procesos hijo, redirección de descriptores de fichero y uso del sistema de pipes. Es un ejercicio preparatorio para proyectos más complejos como la implementación de una mini-shell. En resumen, Pipex enseña a utilizar llamadas al sistema como `pipe()`, `fork()`, `dup2()` y `execve()` para lograr que dos procesos se comuniquen entre sí mediante un flujo de datos (pipeline).

**Tecnologías implicadas:** Lenguaje C (estándar C99/C11) sobre entorno UNIX (Linux/macOS). Uso de llamadas al sistema de bajo nivel: apertura/cierre de ficheros, duplicación de descriptores, creación de procesos y ejecución de otros programas. Se permite reutilizar la librería **libft** propia del estudiante (colección de funciones básicas en C). No se permite utilizar funciones de alto nivel no autorizadas (por ejemplo, no está permitido usar `system()` ni otras funciones fuera de la lista de autorizadas).

## Requisitos Funcionales y Técnicos Obligatorios

**Funcionamiento general:** El programa resultante se llamará `pipex`. Al ejecutarse, **debe recibir exactamente 4 argumentos** en su forma básica: un fichero de entrada, un comando 1, un comando 2 y un fichero de salida. La sintaxis de uso es:

```
./pipex file1 "cmd1 con argumentos" "cmd2 con argumentos" file2
```

Donde:

* **file1** es el nombre del fichero de entrada (se leerá su contenido).
* **cmd1** es el primer comando a ejecutar (con sus parámetros, si los tiene, encerrados entre comillas en la línea de comandos).
* **cmd2** es el segundo comando a ejecutar, que recibirá la salida del primero como entrada.
* **file2** es el nombre del fichero de salida donde volcar el resultado final.

El comportamiento **debe ser exactamente equivalente** a ejecutar el siguiente comando en bash:

```bash
< file1 cmd1 | cmd2 > file2
```

Es decir, redirigir la entrada estándar del **cmd1** para que lea de *file1*, canalizar (`|`) la salida de **cmd1** hacia la entrada de **cmd2**, y finalmente redirigir la salida estándar de **cmd2** hacia *file2* (creando o truncando *file2* según corresponda). El contenido de *file2* tras ejecutar Pipex debe coincidir exactamente con el que produciría la shell al ejecutar la línea equivalente.

**Búsqueda de comandos:** El programa debe ser capaz de localizar los binarios de `cmd1` y `cmd2` usando la variable de entorno PATH, del mismo modo que lo haría la shell. Cada comando se proporciona como una cadena (por ejemplo `"ls -l"`); Pipex necesita parsear esa cadena para separar el nombre del comando y sus argumentos, luego buscar el ejecutable correspondiente en las rutas de PATH (salvo que el comando ya venga indicado con ruta explícita, p.ej. `"/bin/ls"`). Si un comando no se encuentra, debe manejarse el error apropiadamente (ver *Manejo de errores* abajo).

**Llamadas al sistema permitidas:** Están **autorizadas** las funciones de la libc y llamadas al sistema necesarias para implementar la funcionalidad. En particular, el enunciado lista explícitamente las siguientes: `open`, `close`, `read`, `write`, `malloc`, `free` (funciones estándar de E/S y gestión de memoria) y también funciones específicas de UNIX como `strerror`, `access`, `dup`, `dup2`, `execve`, `exit`, `fork`, `pipe`, `unlink`, `wait` y `waitpid`. Asimismo se permite usar `ft_printf` (o su equivalente personal) para formatear salidas. **No** está permitido usar funciones de conveniencia no autorizadas (por ejemplo, `system()`, `popen()` u otras librerías externas), ni funciones de la libc fuera de las mencionadas en la lista del proyecto. El cumplimiento de esta restricción será verificado durante la corrección.

**Makefile y compilación:** Debe entregarse un **Makefile** que compile el proyecto de forma autónoma. El Makefile debe generar un ejecutable llamado *pipex* y respetar los objetivos habituales: al menos `$(NAME)`, `all`, `clean`, `fclean` y `re`. Se evaluará que no relinke innecesariamente y que permita compilar el proyecto desde cero con un simple `make`. Todos los ficheros fuente *.c* y headers *.h* necesarios deben estar presentes en el repositorio (el corrector sólo evaluará lo entregado en el Git, sin añadir nada externo). El código debe compilar sin **warnings** ni errores con **gcc** y las banderas indicadas en el sujet (habitualmente `-Wall -Wextra -Werror`). Si el proyecto no compila, la evaluación termina inmediatamente con puntuación 0.

**Manejo de errores y estabilidad:** El programa debe **manejar exhaustivamente los errores** que puedan ocurrir, de forma robusta:

* **No debe “crashear”** ante situaciones imprevistas. Cualquier fallo como *segmentation faults*, *bus errors*, dobles liberaciones de memoria, etc., provocará que el proyecto sea calificado con 0. Se espera que el estudiante compruebe los retornos de llamadas al sistema (por ejemplo, verificar si `open` devolvió -1 indicando fallo, si `fork` devolvió -1, etc.) y gestione esas situaciones de forma segura.
* **Sin fugas de memoria:** La gestión de memoria dinámica debe ser correcta. Al terminar la ejecución, no debe haber *memory leaks*. El enunciado explícitamente lo requiere. Se recomienda usar herramientas como **Valgrind** durante el desarrollo para asegurar este punto.
* **Salida y mensajes de error:** Los mensajes de error deben enviarse al **stderr** (descriptor 2), no al stdout, para imitar el comportamiento de la shell y no contaminar la salida normal del programa. Por ejemplo, si *file1* no existe, Pipex debería mostrar un error (idealmente indicando el problema, e.g. `"No such file or directory"`) en stderr. Si un comando no se encuentra, igualmente se debe informar por stderr. **Importante:** A pesar de errores en un comando o archivo, **el programa no debe salir de inmediato**, sino comportarse como lo haría bash: por ejemplo, si el fichero de entrada no existe, bash mostrará un error pero igualmente intentará ejecutar el segundo comando (que recibirá entrada vacía). Pipex debe imitar esta lógica, lanzando ambos procesos comandos aunque uno falle, asegurando que los errores se informen pero no se “corte” prematuramente la pipeline.
* **Código de salida:** El valor de retorno del proceso principal de Pipex debería reflejar el resultado de la ejecución del pipeline, normalmente devolviendo el código de salida del último comando ejecutado (tal como hace la shell por defecto). Esto será comprobado durante la corrección automática. Asegúrate de capturar el código de salida de los procesos hijo (por ejemplo con `waitpid`) y retornar apropiadamente.

**Consideraciones adicionales:** Se deben cerrar todos los descriptores de fichero que se abran. En la implementación típica, Pipex abrirá *file1* y *file2*, y creará un pipe (que da dos FD, lectura y escritura). Es crucial **cerrar los extremos del pipe que no se utilicen en cada proceso hijo**, así como cerrar *file1* y *file2* cuando ya no sean necesarios. No hacerlo puede causar que los procesos queden esperando indefinidamente (por ejemplo, una situación clásica es: si no se cierra el extremo de escritura del pipe en el proceso que lee, éste nunca recibe EOF y se queda bloqueado esperando más datos). También es importante liberar cualquier recurso dinámico (memoria reservada) antes de terminar.

## Criterios de Evaluación (Rúbrica estándar 42)

El proyecto Pipex se evalúa mediante **revisión por pares** (*peer-review*). Usualmente, 2 o 3 compañeros actuarán como evaluadores siguiendo una rúbrica proporcionada por la plataforma intranet de 42. Los criterios generales de evaluación incluyen:

* **Verificación inicial del repositorio:** El evaluador clona el repositorio Git y comprueba que pertenece al estudiante/equipo correcto, que el proyecto es efectivamente Pipex y que la estructura de archivos es la esperada (Makefile, etc.). Si faltan archivos obligatorios (ej: no hay Makefile, o no se encuentran los \*.c/\*h correspondientes), la evaluación puede finalizar con 0 puntos.
* **Compilación y Norminette:** Se ejecuta el Makefile. Si hay errores de compilación, la evaluación se detiene (score 0). Luego se pasa la herramienta de estilo **Norminette** sobre el código; **cualquier error de Norminette implica calificación 0** de acuerdo con las reglas de 42. Esto incluye también los ficheros de bonus, si existen. El evaluador comprueba además que no se hayan usado funciones prohibidas (revisando los `#include` y buscando llamadas indebidas).
* **Pruebas funcionales obligatorias:** El corrector revisará que el programa cumpla los requisitos funcionales mínimos. Se probarán casos como:

  * Ejecución básica con un fichero de entrada sencillo, dos comandos triviales y un fichero de salida. Se comparará el contenido de *file2* con el resultado de ejecutar la pipeline equivalente en bash.
  * Caso donde *file1* no existe o no tiene permisos de lectura: Pipex debe mostrar un mensaje de error en stderr pero **aún así** ejecutar el segundo comando (que no recibirá datos). El fichero de salida debería crearse pero posiblemente vacío, replicando el comportamiento de bash.
  * Caso donde *file2* no tiene permisos de escritura (por ejemplo, es de solo lectura): el programa debe mostrar error y terminar adecuadamente.
  * Comandos inexistentes o con errores: por ejemplo `cmd1` inválido (no existente) y un `cmd2` válido. Se espera ver un mensaje de error para el cmd1 faltante, pero la ejecución de cmd2 igualmente ocurrirá (recibiendo entrada vacía). De nuevo, imitar cómo actúa la shell.
  * Verificación de que la salida se redirige correctamente y únicamente la salida estándar de los comandos acaba en *file2*, mientras que los errores van a stderr (no deben aparecer en *file2* los mensajes de error).
* **Gestión de procesos y recursos:** Los evaluadores suelen comprobar manualmente (o mediante pequeños scripts) que el programa **no produce *deadlocks* ni cuelgues**. Por ejemplo, un caso de prueba conocido es usar `cmd1` = `cat` y `cmd2` = `cat` con un fichero de entrada vacío. Si los pipes/descriptores no se cierran correctamente, el segundo `cat` puede quedar esperando entrada indefinidamente. Pipex debe finalizar correctamente en este escenario (posiblemente escribiendo nada en *file2* pero saliendo sin bloquearse). También se puede probar con `/dev/urandom` como entrada para verificar que el programa maneja flujos largos y puede terminar (e.g., quizás al recibir una señal de interrupción para cortar la ejecución).
* **Calidad del código y estructura:** Aunque el evaluador no suele leer todo el código en detalle, sí puede verificar que el código es entendible y sigue las **buenas prácticas**. Esto incluye: funciones cortas y bien definidas (máximo 25 líneas cada una, según la Norm), nombres de variables y funciones significativos, modularización (p. ej., separar lógica de apertura de archivos, ejecución de comandos, etc., en distintos funciones/ficheros), y ausencia de duplicación de código. No es una evaluación tan profunda como la funcional, pero un código extremadamente confuso o desorganizado podría generar dudas en el evaluador. *(Nota: Cualquier violación clara de la Norm será detectada por la herramienta automáticamente, pero más allá de eso, se valora la claridad y mantenibilidad.)*
* **Puntuación:** En la rúbrica de 42, normalmente la parte obligatoria (mandatory) vale hasta 100 puntos. Para obtener el 100%, **todas** las funcionalidades obligatorias deben funcionar correctamente y cumplirse todas las condiciones (norma, no leaks, etc.). Si algún punto obligatorio falla, la nota bajará significativamente o incluso puede ser 0 si es un fallo crítico. Los **bonus** (ver siguiente sección) pueden otorgar puntos **extra**, típicamente elevando la nota máxima posible a 125% (aunque en el campus 42 la nota se registra como 100, se puede superar 100 para fines de honor o ranking). **Importante:** Los bonus **solo se corrigen si** la parte obligatoria es **perfecta** (es decir, 100/100 en mandatory). Si el proyecto obligatorio tiene fallos, los bonus no suman nada.
* **Pruebas automáticas (Deepthought):** Tras la evaluación manual por pares, suele haber una capa de verificación automática conocida como **Deepthought**. Este sistema ejecuta una batería de tests adicionales más exhaustivos. Por ejemplo, verifica ausencia de **memory leaks** con Valgrind en ejecuciones de prueba, comprueba comportamientos en casos extremos y compara salidas con las esperadas. Si **alguna** de estas pruebas automáticas falla (por ejemplo, el programa se cuelga, o la salida difiere, o hay un error de memoria), **la corrección se detiene inmediatamente** y el proyecto se considera suspenso en ese punto. Por ello, es crucial probar el programa en tantos escenarios como sea posible antes de entregarlo, asegurando robustez. Los evaluadores humanos también pueden ejecutar algunas pruebas del estilo de Deepthought manualmente (ej., correr Valgrind ellos mismos) si lo estiman necesario.

En resumen, la evaluación valorará que **Pipex funcione exactamente como se pide**, manejando correctamente la redirección y pipes entre dos comandos, sin errores de estilo o memoria, y replicando el comportamiento de la shell tanto en funcionalidad como en manejo de errores.

## Reglas de Estilo y Buenas Prácticas de Código

Como en todos los proyectos de 42, el código de Pipex debe respetar al 100% la **Norma de Estilo de 42** (Norminette). Esto implica numerosas reglas sobre el formato y la estructura del código:

* **Norminette 100% limpia:** Cualquier error de Norm (ya sea en archivos obligatorios o bonus) resulta en un 0 automático. Esto abarca, por ejemplo, indentación consistente (4 espacios por nivel), longitud máxima de línea (80 caracteres), nombre de funciones y variables en formato lower\_snake\_case, prohibición de variables globales, número limitado de variables locales por función, etc. El evaluador ejecutará la Norminette para verificarlo.
* **Organización del proyecto:** Si bien el sujet no impone una estructura de carpetas estricta, es una buena práctica estructurar el código. Por ejemplo, se suele tener un directorio `src/` para los *.c*, un `includes/` para *.h*, etc., y un archivo README (opcional). El **Makefile** debe estar en la raíz del repositorio y manejar las dependencias entre estos archivos. Asegurarse de nombrar correctamente los archivos y funciones según su rol (p.ej., `pipex.c` con la función `main`, `pipex_utils.c` para funciones auxiliares, `pipex.h` para declaraciones comunes, etc.). Durante la corrección, se revisará que los nombres de archivos entregados coincidan con los esperados (cuidar mayúsculas/minúsculas, ortografía).
* **Funciones modulares y reutilizables:** Se espera que el código esté dividido en funciones que cada una realice una tarea específica (principio de responsabilidad única). Dado el límite de 25 líneas por función de la Norm, esto es prácticamente obligatorio. Por ejemplo, podrían existir funciones como `parse_command(char *cmd_str, char **envp)` para obtener el path ejecutable y argumentos, `execute_command(char *path, char **args, char **envp)` para hacer el `execve`, etc. Esto mejora la legibilidad y facilita la corrección.
* **Manejo explícito de errores:** En concordancia con la robustez esperada, el código debe verificar los retornos de cada llamada importante. Si `open(file1)` falla, por ejemplo, se debe imprimir un mensaje de error descriptivo (usando `perror` o construyendo uno con `strerror(errno)` y write/ft\_printf). La función `execve` no retorna si tiene éxito (el proceso hijo se reemplaza); pero si retorna -1, se debe manejar como error de ejecución del comando. Los evaluadores prestarán atención a cómo se manejan estos casos en el código.
* **Libft y reutilización de código:** Está permitido y recomendado usar la librería libft para funciones de utilidad (como dividir strings, manejar memoria, etc.). No se debe “re-inventar la rueda” para cosas que ya se disponen en libft, siempre y cuando estén permitidas. Incluir el `libft.a` o añadirlo al Makefile es común. Asegurarse de no introducir en libft funciones no permitidas por Pipex (libft en general solo tiene funciones estándares).
* **Comentarios y legibilidad:** La Norm no prohíbe los comentarios (excepto el código comentado innecesario), pero es aconsejable documentar las partes complejas. Un evaluador agradece, por ejemplo, ver un comentario breve antes de una sección de código que crea los procesos y los pipes, explicando qué se hace. También es buena práctica imprimir por pantalla (en modo debug, que luego se retira) información durante el desarrollo para depurar, pero **no** dejar prints de debug activos en la versión final entregada (salvo que formen parte de la funcionalidad).
* **Separación del código Bonus:** Si se implementan funcionalidades extra, **deben aislarse en archivos separados** con el sufijo *\_bonus.c/h*. Además, el Makefile debe tener la regla `bonus` que compile estos ficheros adicionales cuando se invoque específicamente. El cumplimiento de esta separación será verificado. Por ejemplo, `pipex_bonus.c` podría contener la lógica para múltiples pipes y here\_doc, y solo compilarse con `make bonus`. Esto ayuda a los evaluadores a distinguir qué es obligatorio y qué es bonus durante la revisión del código.

Respetar todas estas reglas de estilo no solo evita la penalización automática, sino que demuestra profesionalidad y facilita que otros (incluyendo el evaluador) entiendan el código.

## Errores Comunes y Puntos Críticos

A lo largo de la corrección de Pipex, se han identificado una serie de errores típicos que cometen los estudiantes. Presta atención especial a estos puntos críticos para evitar caer en ellos:

* **No cerrar correctamente los *file descriptors* (FD):** Un error frecuente es olvidar cerrar los extremos de pipe no utilizados o los ficheros abiertos, provocando bloqueos. Por ejemplo, si ninguno de los procesos cierra el extremo de escritura del pipe, el proceso lector puede quedar esperando indefinidamente (casos como `cat | cat` se quedan “colgados”). Asegúrate de cerrar **en el proceso hijo 1** el extremo de lectura de la tubería (porque solo escribe en el pipe) y en el **proceso hijo 2** el extremo de escritura (porque solo lee del pipe). El proceso padre, tras crear a los hijos, debe cerrar ambos extremos del pipe también. Igualmente, cerrar los FD de *file1* y *file2* en los procesos donde ya no se necesiten. Esto previene deadlocks y fugas de descriptores.
* **Mismanagement de la redirección de errores:** Todos los mensajes de error deben ir al **stderr**. Un error común es imprimir errores en stdout o no especificar el file descriptor, con lo cual mensajes como *"command not found"* terminan en el fichero de salida por redirección, lo que es incorrecto. Utiliza `ft_printf(2, "...")` o `dprintf(2, "...")`, `perror()` o `write(2, ... )` para los errores, de modo que no interfieran con la salida normal.
* **Olvidar terminar los argumentos de `execve` con NULL:** Al preparar el array de parámetros para `execve`, muchos estudiantes construyen un `char **argv_exec` pero olvidan colocar un elemento `NULL` al final de la lista. Esto provocará errores de lectura de memoria en `execve` (comportamiento indefinido). Siempre asegúrate de que el último elemento de argv para `execve` sea NULL (ej.: si usas `ft_split` para separar la línea de comando en palabras, tendrás que reallocar o asegurarte de que añade un NULL terminador).
* **Uso incorrecto de flags en `open`:** Para abrir el fichero de salida (*file2*), se debe tener cuidado con los flags y permisos. En el caso normal (no bonus), *file2* debe abrirse con permisos de escritura, creando/truncando el fichero (`O_CREAT | O_TRUNC | O_WRONLY`). En el caso del **modo here\_doc (bonus)**, *file2* debe abrirse en modo append (`O_CREAT | O_APPEND | O_WRONLY`), ya que la salida se añade al final en vez de truncar. Usar flags equivocados puede dar lugar a que el resultado no coincida con la shell (p.ej., truncar cuando debería anexar, o viceversa).
* **No eliminar archivos temporales (bonus):** Algunos estudiantes implementan el here\_doc volcando el contenido proporcionado por el usuario a un fichero temporal que luego usan como entrada. Si se sigue esta estrategia, es fundamental **borrar el archivo temporal** al terminar (por ejemplo con `unlink()` tras haberlo usado). Olvidar hacerlo ensucia el directorio de trabajo con ficheros intermedios y puede afectar correcciones sucesivas.
* **Abortar el programa ante el primer error:** Como se mencionó, Pipex debe imitar la shell. Un error en la apertura de *file1* o en la ejecución de `cmd1` **no debe abortar todo el programa inmediatamente**. Un error común es hacer `exit(EXIT_FAILURE)` en cuanto algo falla. En lugar de eso, se debe manejar grácilmente: imprimir el error correspondiente y, en procesos hijo, hacer `exit` con código de fallo, pero permitiendo que el flujo general continúe para los demás comandos y finalmente el programa principal termine. Solo se debe terminar inmediatamente si el fallo impide totalmente continuar (por ejemplo, si `pipe()` o `fork()` fallaran, en cuyo caso no se puede proseguir). En resumen, **no terminar el proceso padre prematuramente** por errores en hijos; manejarlo adecuadamente.
* **No recoger (*wait*) a los procesos hijo:** A veces se olvida llamar a `waitpid` para cada proceso creado. Esto puede dejar **procesos zombie** tras la ejecución de Pipex. Asegúrate de invocar `waitpid(pid1, ...)` y `waitpid(pid2, ...)` (almacenando sus PID tras `fork()`), para que el sistema libere correctamente la información de finalización de los hijos. Además, como ya se dijo, eso te permite obtener el código de salida del segundo comando para retornarlo en pipex.
* **Memory leaks y dobles `free`:** Son errores clásicos en C. Verifica que cada `malloc` tenga su correspondiente `free` en todos los caminos de ejecución. Usa Valgrind durante tus pruebas. Un error típico es **liberar dos veces** una misma dirección o liberar memoria que aún necesitas (use-after-free). Estos errores pueden no provocar crash inmediato pero sí saldrán en Valgrind o en Deepthought, causando la interrupción de la evaluación. Maneja con cuidado las cadenas duplicadas (por ejemplo, si duplicas la PATH en otra variable, libera lo que corresponda al final).
* **Casos especiales de dispositivos:** Aunque no es obligatorio cubrir todos, en pruebas automáticas pueden usar archivos especiales como `/dev/null` (archivo vacío), `/dev/urandom` (flujo infinito de bytes aleatorios) o `/dev/stdin`. Asegúrate de que Pipex maneja de forma razonable la lectura de estos (p.ej., no intentar leer infinitamente de `/dev/urandom` si no es necesario, quizás limitando la lectura porque el comando receptor podría terminar antes). En general, tu programa debería comportarse como la shell en dichos casos (por ejemplo, `< /dev/null cat | cmd2` simplemente hará que cat reciba EOF inmediato). Estos casos suelen revelar si cerraste bien los pipes o si sabes terminar procesos.

Con la debida atención a estos detalles, evitarás la mayoría de las caídas y fallos comunes reportados en correcciones anteriores.

## Elementos Bonus (Opcionales) para Puntos Adicionales

El proyecto Pipex ofrece la posibilidad de implementar funcionalidades adicionales para obtener **puntos bonus**, siempre y cuando la parte obligatoria funcione perfectamente al 100%. Los bonus consisten en extender la lógica del pipeline a escenarios más generales:

* **Soporte de múltiples comandos (múltiples pipes encadenados):** En la versión básica solo se manejan 2 comandos con 1 pipe intermedio. Un bonus importante es permitir **N comandos** intermedios. Es decir, que `pipex` pueda recibir más de dos comandos y encadenarlos todos. La sintaxis propuesta es:

  ```
  ./pipex file1 cmd1 cmd2 cmd3 ... cmdN file2
  ```

  Esto debe comportarse como encadenar N comandos en la shell, por ejemplo:

  ```bash
  < file1 cmd1 | cmd2 | cmd3 | ... | cmdN > file2
  ```

  .  En la práctica, esto implica crear **múltiples pipes** y posiblemente múltiples procesos hijo (uno por comando intermedio adicional). Cada comando i (excepto el primero y el último) toma la salida del anterior y pasa su salida al siguiente. La implementación requiere lógica para manejar múltiples pipes en serie (por ejemplo, en un bucle), abriendo nuevos pipes y conservando extremos adecuados. Este bonus demuestra comprensión avanzada de la comunicación entre procesos.

* **Here\_doc (Heredoc) y append en salida:** Otra funcionalidad extra es soportar una sintaxis de **“aquí documento”** similar a la shell. En este modo, en lugar de leer de un fichero de entrada existente, el programa leerá la entrada desde el **STDIN del usuario** hasta que éste escriba una línea que coincida con un delimitador dado. La forma de ejecutar sería:

  ```
  ./pipex here_doc LIMITER cmd1 cmd2 ... cmdN file2
  ```

  Donde la cadena `here_doc` en el primer argumento activa este modo, `LIMITER` es la palabra clave que delimita el final de la entrada (no se incluye en la entrada final), los siguientes son comandos a encadenar, y *file2* es el fichero de salida. El comportamiento debe ser equivalente a la shell haciendo:

  ```bash
  cmd1 << LIMITER | cmd2 | ... | cmdN >> file2
  ```

  . Es decir, leer desde STDIN todas las líneas hasta encontrar una línea que contenga solo `LIMITER` (sin incluirla), enviar ese bloque de texto como entrada al primer comando, y redirigir la salida final en modo **append** al fichero de salida (usar `>>` en lugar de `>` para no truncar el contenido previo). Implementar esto implica usar posiblemente `get_next_line` o leer en bucle de STDIN, comparar con la cadena limitadora, etc. **Nota:** No olvidar abrir *file2* con `O_APPEND` en este modo y, si se usa un fichero temporal para almacenar el here\_doc, borrarlo luego.

* **Gestión de errores análoga en bonus:** Tanto para múltiples pipes como para here\_doc, se espera el mismo nivel de manejo de errores. Por ejemplo, si alguno de los comandos intermedios falla o no existe, debe mostrarse error pero continuar la ejecución del resto. Si en modo here\_doc se recibe EOF (fin de entrada) antes de encontrar el LIMITER, se debería tratar adecuadamente (posiblemente terminar la lectura). Todos los principios de robustez del apartado obligatorio aplican igualmente a los bonus.

Para implementar los bonus, recuerda las reglas mencionadas: separar su código en archivos *\_bonus.c*, y proporcionar la regla `make bonus`. Los evaluadores solo corregirán los bonus si el programa base es perfecto. De estar bien hechos, los bonus pueden sumar algunos puntos adicionales que marquen la diferencia en la nota final.

## Checklist de Evaluación (Ejemplo)

A continuación se presenta una **lista de verificación** a modo de rúbrica resumida. Un evaluador podría usarla para chequear punto por punto el proyecto Pipex:

* [ ] **Repositorio y Entrega:** El repositorio Git clona correctamente y contiene los archivos requeridos (Makefile, \*.c, \*.h). El ejecutable generado se llama **pipex**.
* [ ] **Compilación:** `make` compila todos los fuentes sin errores ni *warnings*. No se produce relink al recompilar sin cambios.
* [ ] **Norminette:** El código pasa la Norminette sin errores en **todos** los archivos (incluyendo bonus). Formato y estilo adecuados.
* [ ] **Uso básico – Pipeline de 2 comandos:** Ejecutar `./pipex infile "cmd1 arg..." "cmd2 arg..." outfile` produce exactamente el mismo resultado que `< infile cmd1 | cmd2 > outfile` en bash. El contenido de *outfile* es correcto y los comandos se ejecutan apropiadamente.
* [ ] **Redirección de I/O:** *infile* se abre y se usa como entrada de **cmd1**; *outfile* contiene la salida de **cmd2** (debe crearse o truncarse correctamente). Si *outfile* no existía, el programa lo crea con permisos adecuados; si existía, se sobreescribe (modo trunc).
* [ ] **Búsqueda de comandos:** Si se pasan comandos sin ruta (`ls`, `grep`, etc.), el programa los encuentra usando PATH. Comandos con ruta absoluta o relativa (`/bin/ls`, `./a.out`) también funcionan.
* [ ] **Manejo de errores – Archivos:** Si *infile* no existe o no se puede abrir, se muestra un mensaje de error descriptivo en **stderr** (por ejemplo, utilizando `perror` o mensaje custom con strerror). El programa **no aborta**; continúa intentando ejecutar cmd1 (que recibiría EOF inmediato) y luego cmd2. *outfile* igualmente debería crearse (aunque quizás vacío).
* [ ] **Manejo de errores – Comandos:** Si algún comando es inválido/no ejecutable, se muestra error en stderr (ej. "`command not found`" u otro mensaje apropiado). El resto de comandos en la secuencia se ejecutan igualmente. El programa principal termina normalmente sin colapsar ante comandos inexistentes.
* [ ] **Salida estándar vs error:** Los mensajes de error **no** aparecen en *outfile*, solo en la consola (stderr). El fichero de salida solo contiene lo que el pipeline válido imprimió por stdout.
* [ ] **Códigos de retorno:** El código de salida de `pipex` (echo `$?`) corresponde al código del último comando ejecutado (o alguna lógica coherente si hubo errores). Ej.: si cmd2 retorna 0, pipex retorna 0; si cmd2 falla con código 127, pipex devuelve 127, etc.
* [ ] **Procesos y descriptores:** No se producen bloqueos. Casos de prueba como `./pipex infile "cat" "cat" outfile` terminan adecuadamente (posible error si *infile* vacío, pero no cuelga). Pruebas con entradas grandes o infinitas (como `/dev/urandom`) no cuelgan indefinidamente el programa una vez que cmd2 finaliza. Todos los pipes y ficheros se cierran en su debido momento, evitando *deadlocks*.
* [ ] **Memoria:** Ejecuciones bajo herramientas como Valgrind no reportan pérdidas de memoria ni accesos inválidos. Cada reserva de memoria (`malloc`) tiene su `free`. No hay *double frees* ni *segfaults*.
* [ ] **Código – Calidad general:** El código es legible y bien organizado. Las funciones son coherentes con un propósito específico y respetan los límites de tamaño. No se encuentran hacks o prácticas inseguras. El Makefile, estructura de directorios y nombres siguen convenciones claras.
* [ ] **Bonus – Múltiples comandos:** Si corresponde, se prueba `./pipex infile "cmd1" "cmd2" "cmd3" outfile` (o más comandos). El resultado equivale a encadenar todos los comandos en shell `< infile cmd1 | cmd2 | cmd3 > outfile`. Funciona con N comandos arbitrarios.
* [ ] **Bonus – here\_doc:** Si implementado, probar `./pipex here_doc LIMITER "cmd1" "cmd2" outfile`. El programa lee desde stdin hasta encontrar `LIMITER` en línea sola, luego alimenta ese input a cmd1. La salida final se **concatena** a *outfile* en vez de truncarlo. Se verifica que al repetir la ejecución con el mismo *outfile*, los nuevos datos se añaden. También comprobar que ctrl-D (EOF) antes de LIMITER se maneja (posible fin abrupto del heredoc).
* [ ] **Bonus – manejo de errores:** En modos bonus, se mantienen las mismas garantías: múltiples pipes no rompen si un comando falla; here\_doc muestra errores si no puede crear *outfile*, etc., y no deja archivos temporales huérfanos (si usó uno, debe borrarse).
* [ ] **Entrega completa:** Ningún archivo extrañas (temporales, outputs de debug) en el repo. Código bien presentado. El proyecto cumple su objetivo de explorar a fondo el mecanismo de pipes en UNIX.

Si todos los puntos anteriores se cumplen satisfactoriamente, el proyecto Pipex merece la máxima puntuación. En caso contrario, esta lista ayuda a identificar rápidamente las áreas problemáticas a corregir. ¡**Buena suerte** en la implementación y revisión de Pipex!
